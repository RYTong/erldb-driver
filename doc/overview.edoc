@title Erlang database driver
@author cao.xu <cao.xu@rytong.com>
@author deng.lifen <deng.lifen@rytong.com>
@author wang.meigong <wang.meigong@rytong.com>
@copyright 2009-2010 Beijing RYTong Information Technologies, Ltd.
@version {@vsn}

@doc
== Contents ==
{@section Introduction}<br/>
{@section Design Purpose}<br/>
{@section Download}<br/>
{@section Installation}<br/>
{@section Documentation}<br/>
{@section Configuration}<br/>
{@section Getting Started}<br/>
{@section Tests}<br/>
{@section Data Type}<br/>
{@section Notices}<br/>
{@section Having Problems?}<br/>

== Introduction ==

<p>The db_driver is a high performance database driver based on the Erlang linked-in driver. It uses asynchronous threads to avoid IO block during the database access, the same way in which Erlang asynchronous drivers were implemented. We followed the syntax of Erlydb (erlang_mysql_driver) to design the APIs. For one database access request, the parameters will be passed to driver and processed in asynchronous threads. Then the request will be translated to respective SQL statements for different database types. After that, the work threads will call vendors' C/C++ APIs to execute these SQL statements and return the responses with ei.</p>
<p>Now the driver supports MySQL, Oracle, Sybase, DB2 and Informix.</p>
<p></p>

== Design Purpose ==

We want to support most typical database systems, such as Mysql, Oracle, Sybase, DB2 and Informix, but we don't choose ODBC because of its poor performance.

== Download ==

This is Download.

== Installation ==

In the db_driver directory, execute
```
./configure
make
sudo make install
'''

If you installed rebar, you can execute

```
rebar compile
'''

== Documentation ==

In the db_driver directory, execute
```
make doc
'''
If you installed rebar, you can execute

```
rebar doc
'''

to generate Erlang API.

The Database-Driven Documentation generated by doxygen. If you installed
doxygen, you can execute
```
make libdoc
'''
to generated C API.

See <a href="lib/html/index.html" target="_black">Database-Driven Documentation</a>

== Configuration ==

To use db_driver, you need to configure db_driver to make default database
connection for database-driven start-up. The connection parametes likes: 
```
PoolId = test,
ConnArgs =  [{driver, mysql},
             {database, "test"},
             {host, "localhost"},
             {user, "root"},
             {password, ""},
             {poolsize, 8}
             ].
'''
where connect_name is the name of your connection instance, the type is atom.

The following is required parameters.

```
driver::atom()          Database type. Supported mysql, oracle and sybase.
database::string()      Database name.
host::string()          Database host name or IP address.
user:string()           Database user.
password:string()       Database password.
poolsize::integer()     Connection pool size.
'''
The following is optional parameters.

```
port::integer()             Database port. Default is 3306.
default_pool::boolean()     Default Connection pool.
error_handler::{Mod, Fun}   Callback Function of error handler.
'''


== Getting Started ==

1.Starts by default pool mode.
```
%% Start db driver.
db_api:start().

%% Connection instance Id.
PoolId = 'test'.

%% Connection args.
ConnArg = [{driver, mysql},
           {database, "test"},
           {host, "localhost"},
           {user, "root"},
           {password, ""},
           {poolsize, 8},
           {default_pool, true}].

%% Add a connection pool.
db_api:add_pool(PoolId, ConnArg).

%% Execute sql string.
db_api:execute_sql("select version()").

%% If you didn't set the default pool flag, you can execute sql like this.
db_api:execute_sql("select version()", [{pool, PoolId}]).

%% Remove a connecttion pool.
db_api:remove_pool(PoolId),

%% Stop db driver.
db_api:stop().
'''

If you set the dafault pool flag in several connection pools, 
the default pool is the last added pool. 

== Tests ==
See test cases in module basic_SUITE, module informix_SUITE and module oracle_SUITE.

== Data Type ==

The following is the mapping of database data type to Erlang data type.

1. MySQL data type.
```
BIT             integer()
TINYINT         integer()
BOOL, BOOLEAN   integer()
SMALLINT        integer()
MEDIUMINT       integer()
INT             integer()
INTEGER         integer()
BIGINT          integer()
FLOAT           float()
DOUBLE          float()
FLOAT           float()
DECIMAL         float()
DATE            {date, {Year::integer(), Month::integer(), Day::integer()}}
DATETIME        {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIMESTAMP       {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIME            {time, {Hour::integer(), Minute::integer(), Second::integer()}}
YEAR            integer()
CHAR            integer()
VARCHAR         string()
BINARY          string()
VARBINARY       string()
TINYBLOB        binary()
TINYTEXT        string()
BLOB            binary()
TEXT            string()
MEDIUMBLOB      binary()
MEDIUMTEXT      string()
LONGBLOB        binary()
LONGTEXT        string()
'''

2. Oracle data type.
```
STRING          string()
NUMBER          number()
DATE            {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIMESTAMP       {timestamp,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Microseconds::integer()},
                     {TimeZoneOffsetInHours::integer(),
                      TimeZoneOffsetInMinutes::integer()}}}
TIMESTAMP_Z     {timestamp,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Microseconds::integer()},
                     {TimeZoneOffsetInHours::integer(),
                      TimeZoneOffsetInMinutes::integer()}}}
TIMESTAMP_LZ    {timestamp,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Microseconds::integer()},
                     {TimeZoneOffsetInHours::integer(),
                      TimeZoneOffsetInMinutes::integer()}}}
BINARY          binary()
CLOB            string()
NCLOB           string()
BLOB            binary()
INTERVAL_YM     {interval_ym, {Year::integer(), Month::integer()}}}
INTERVAL_DS     {interval_ds,
                    {Day::integer(),
                     Hour::integer(),
                     Minute::integer(),
                     Second::integer(),
                     FractionalSecondComponent::integer()}}
'''

3. Sybase data type.
```
VARBINARY       binary()
BIT             integer()
CHAR            string()
VARCHAR         string()
UNICHAR         list()
UNIVARCHAR      list()
DATE            {date, {Year::integer(), Month::integer(), Day::integer()}}
TIME            {time,
                    {Hour::integer(),
                     Minute::integer(),
                     Second::integer(),
                     Millisecond::integer()}}
DATETIME        {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Millisecond::integer()}}}
SMALLDATETIME   {smalldatetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer()}}}
TINYINT         integer()
SMALLINT        integer()
INT             integer()
BIGINT          integer()
DECIMAL         {number, string()}
NUMERIC         {number, string()}
FLOAT           float()
REAL            float()
MONEY           {number, string()}
SMALLMONEY      float()
'''

== Notices ==
1. Oracle prepare statement.
    Prepare sql is like "select ?,? from user", but prepare sql in Oracle is like "select :1,:2 from user".
    You can consistently use two methods in module db_api, but you can only use the second method in module db_driver.


== Having Problems? ==

This is problems.
