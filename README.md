

# Erlang database driver #

Copyright (c) 2013-2014 Beijing RYTong Information Technologies, Ltd.

__Version:__ 2.0


__Authors:__ cao.xu ([`cao.xu@rytong.com`](mailto:cao.xu@rytong.com)), deng.lifen ([`deng.lifen@rytong.com`](mailto:deng.lifen@rytong.com)), wang.meigong ([`wang.meigong@rytong.com`](mailto:wang.meigong@rytong.com)).



### <a name="Contents">Contents</a> ###


[Introduction](http://github.com/esl/edown/blob/master/doc/README.md#Introduction)
<br></br>

[Design Purpose](http://github.com/esl/edown/blob/master/doc/README.md#Design_Purpose)
<br></br>

[Download](http://github.com/esl/edown/blob/master/doc/README.md#Download)
<br></br>

[Installation](http://github.com/esl/edown/blob/master/doc/README.md#Installation)
<br></br>

[Documentation](http://github.com/esl/edown/blob/master/doc/README.md#Documentation)
<br></br>

[Configuration](http://github.com/esl/edown/blob/master/doc/README.md#Configuration)
<br></br>

[Getting Started](http://github.com/esl/edown/blob/master/doc/README.md#Getting_Started)
<br></br>

[Tests](http://github.com/esl/edown/blob/master/doc/README.md#Tests)
<br></br>

[Data Type](http://github.com/esl/edown/blob/master/doc/README.md#Data_Type)
<br></br>

[Notices](http://github.com/esl/edown/blob/master/doc/README.md#Notices)
<br></br>

[Having Problems?](http://github.com/esl/edown/blob/master/doc/README.md#Having_Problems?)
<br></br>



### <a name="Introduction">Introduction</a> ###

The db_driver is a high performance database driver based on the Erlang linked-in driver. It uses asynchronous threads to avoid IO block during the database access, the same way in which Erlang asynchronous drivers were implemented. We followed the syntax of Erlydb (erlang_mysql_driver) to design the APIs. For one database access request, the parameters will be passed to driver and processed in asynchronous threads. Then the request will be translated to respective SQL statements for different database types. After that, the work threads will call vendors' C/C++ APIs to execute these SQL statements and return the responses with ei.


Now the driver supports MySQL, Oracle, Sybase, DB2 and Informix.





### <a name="Design_Purpose">Design Purpose</a> ###

We want to support most typical database systems, such as Mysql, Oracle, Sybase, DB2 and Informix, but we don't choose ODBC because of its poor performance.


### <a name="Download">Download</a> ###

This is Download.


### <a name="Installation">Installation</a> ###
In the db_driver directory, execute

```
./configure [--with-mysql, --with-oracle, --with-sybase, --with-db2 or --with-informix]
make
sudo make install
```
If you installed rebar, you can execute

```
rebar compile
```

### <a name="Documentation">Documentation</a> ###
In the db_driver directory, execute

```
make doc
```
If you installed rebar, you can execute

```
rebar doc
```

to generate Erlang API.
The Database-Driven Documentation generated by doxygen. If you installed
doxygen, you can execute

```
make libdoc
```


to generated C API.

See [Database-Driven Documentation](http://github.com/esl/edown/blob/master/lib.md/index.html)


### <a name="Configuration">Configuration</a> ###
To use db_driver, you need to configure db_driver to make default database
connection for database-driven start-up. You can do this by editing the the
following Erlang term to your db.conf file:

```
{connect_name, [{driver, mysql},
                {database, "test"},
                {host, "localhost"},
                {user, "root"},
                {password, ""},
                {poolsize, 8}
                ]}.
```


where connect_name is the name of your connection instance, the type is atom.

The following is required parameters.

```
driver::atom()          Database type. Supported mysql, oracle and sybase.
database::string()      Database name.
host::string()          Database host name or IP address.
user:string()           Database user.
password:string()       Database password.
poolsize::integer()     Connection pool size.
threadlength::integer() Thread length.
```


The following is optional parameters.

```
port::integer()             Database port. Default is 3306.
default_pool::boolean()     Default Connection pool.
error_handler::{Mod, Fun}   Callback Function of error handler.
```

The configuration file support configures many connections. You can get
connection parameters by call db_server:get_db_config(ConfigName, ConfigPath).
ConfigName is configuration connect_name, ConfigPath is the configuration files path. db_server:get_db_config(ConfigName) use default configuration files path (config/db.conf).


### <a name="Getting_Started">Getting Started</a> ###
1.Starts by normal mode.

```
%% Start db driver.
Pid = db_driver:start().

%% Connection args.
ConnArg = db_server:get_db_config(ConnectName).
%% Or
ConnArg = [{driver, mysql},
           {database, "test"},
           {host, "localhost"},
           {user, "root"},
           {password, ""},
           {threadlength, 10},
           {poolsize, 8}].

%% Create a connection.
{ok, ConnPool} = db_driver:connect(ConnArg).

%% Execute sql string.
db_driver:execute_sql(ConnPool, "select version()").

%% Destroy a connect.
db_driver:disconnect(ConnPool),

%% Stop db driver.
db_driver:stop(Pid).
```

2.Starts by server mode.

Starts by the server mode, the connection information and fields information
storage in ets table, you may use the default connection or the connection has connected to execute the database operation.

```
%% Start db server and db driver.
db_server:start().

%% Initialization default connection, the ConnectName is configured in db.conf.
db_server:init_default(ConnectName).

%% You can use the functions in module db_api to execute the database operation
%% after start db server and create default connection.
db_api:execute_sql("select version()").

%% ConnectName is configured in db.conf.
ConnectArgs = db_server:get_db_config(ConnectName).

%% Create a new connection.
db_server:connect(ConnectName, ConnectArgs).

%% Operate database by use the connection.
db_api:execute_sql("select version()", [{db_name, ConnectName}]).

%% If you do not need to operation database any more, please stop the db server.
db_server:stop().
```


### <a name="Tests">Tests</a> ###


See test cases in module db_sample and module db_driver_test.


### <a name="Data_Type">Data Type</a> ###

The following is the mapping of database data type to Erlang data type.
1. MySQL data type.

```
BIT             integer()
TINYINT         integer()
BOOL, BOOLEAN   integer()
SMALLINT        integer()
MEDIUMINT       integer()
INT             integer()
INTEGER         integer()
BIGINT          integer()
FLOAT           float()
DOUBLE          float()
FLOAT           float()
DECIMAL         float()
DATE            {date, {Year::integer(), Month::integer(), Day::integer()}}
DATETIME        {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIMESTAMP       {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIME            {time, {Hour::integer(), Minute::integer(), Second::integer()}}
YEAR            integer()
CHAR            integer()
VARCHAR         string()
BINARY          string()
VARBINARY       string()
TINYBLOB        binary()
TINYTEXT        string()
BLOB            binary()
TEXT            string()
MEDIUMBLOB      binary()
MEDIUMTEXT      string()
LONGBLOB        binary()
LONGTEXT        string()
```
2. Oracle data type.

```
STRING          string()
NUMBER          number()
DATE            {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer(), Second::integer()}}}
TIMESTAMP       {timestamp,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Microseconds::integer()},
                     {TimeZoneOffsetInHours::integer(),
                      TimeZoneOffsetInMinutes::integer()}}}
TIMESTAMP_Z     {timestamp,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Microseconds::integer()},
                     {TimeZoneOffsetInHours::integer(),
                      TimeZoneOffsetInMinutes::integer()}}}
TIMESTAMP_LZ    {timestamp,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Microseconds::integer()},
                     {TimeZoneOffsetInHours::integer(),
                      TimeZoneOffsetInMinutes::integer()}}}
BINARY          binary()
CLOB            string()
NCLOB           string()
BLOB            binary()
INTERVAL_YM     {interval_ym, {Year::integer(), Month::integer()}}}
INTERVAL_DS     {interval_ds,
                    {Day::integer(),
                     Hour::integer(),
                     Minute::integer(),
                     Second::integer(),
                     FractionalSecondComponent::integer()}}
```
3. Sybase data type.

```
VARBINARY       binary()
BIT             integer()
CHAR            string()
VARCHAR         string()
UNICHAR         list()
UNIVARCHAR      list()
DATE            {date, {Year::integer(), Month::integer(), Day::integer()}}
TIME            {time,
                    {Hour::integer(),
                     Minute::integer(),
                     Second::integer(),
                     Millisecond::integer()}}
DATETIME        {datetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(),
                      Minute::integer(),
                      Second::integer(),
                      Millisecond::integer()}}}
SMALLDATETIME   {smalldatetime,
                    {{Year::integer(), Month::integer(), Day::integer()},
                     {Hour::integer(), Minute::integer()}}}
TINYINT         integer()
SMALLINT        integer()
INT             integer()
BIGINT          integer()
DECIMAL         {number, string()}
NUMERIC         {number, string()}
FLOAT           float()
REAL            float()
MONEY           {number, string()}
SMALLMONEY      float()
```


### <a name="Notices">Notices</a> ###


1. Oracle prepare statement.
Prepare sql is like "select ?,? from user", but prepare sql in Oracle is like "select :1,:2 from user".
You can consistently use two methods in module db_api, but you can only use the second method in module db_driver.


### <a name="Having_Problems?">Having Problems?</a> ###
This is problems.


## Modules ##


<table width="100%" border="0" summary="list of modules">
<tr><td><a href="http://github.com/esl/edown/blob/master/doc/db_api.md" class="module">db_api</a></td></tr>
<tr><td><a href="http://github.com/esl/edown/blob/master/doc/db_app.md" class="module">db_app</a></td></tr>
<tr><td><a href="http://github.com/esl/edown/blob/master/doc/db_conn.md" class="module">db_conn</a></td></tr>
<tr><td><a href="http://github.com/esl/edown/blob/master/doc/db_conn_server.md" class="module">db_conn_server</a></td></tr>
<tr><td><a href="http://github.com/esl/edown/blob/master/doc/db_stmt.md" class="module">db_stmt</a></td></tr>
<tr><td><a href="http://github.com/esl/edown/blob/master/doc/db_sup.md" class="module">db_sup</a></td></tr>
<tr><td><a href="http://github.com/esl/edown/blob/master/doc/db_util.md" class="module">db_util</a></td></tr></table>

